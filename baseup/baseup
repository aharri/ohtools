#!/bin/sh
#
# $Id: baseup,v 1.31 2010/11/27 18:57:45 iku Exp $
#
# Copyright (c) 2007 Antti Harri <iku@openbsd.fi>
#

VERBOSE=1
CURL_OPTS="-s -4"
BASE=$(cd -- "$(dirname -- "$0")"; pwd)
CONFIG="${BASE}/.config"
FUNCS="$BASE/functions.sh"
TEMPS="$BASE/tmp"
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

args=$(getopt h $*)
set -- $args
while [ $# -ge 0 ]; do
	case "$1"
	in
		'-h') usage ; shift;;
		'-?') usage ; shift;;
		--) shift; break;;
	esac
done

# pick up functions
. "$FUNCS"

# check for first run
get_config state || set_config state install_kernel

# set up temp directory if it doesn't exist
if [ ! -d "$TEMPS" ]; then
	# just mkdir it, we don't have anything secrets to store
	mkdir -p "$TEMPS" 
fi

# main
get_config state
case "$_VAL" in
	"install_kernel" ) # in the middle of fetching files
		get_config source
		if [ "$_VAL" != "" ]; then
			# Clean from previous run.
			yesno "Wipe out files from previous run?"
			if [ "$?" -eq 0 ]; then
				rm -f "${TEMPS}/"*.tgz "${TEMPS}/"bsd* "${TEMPS}/"*boot*
			fi
		fi

		# SOURCE
		get_config source
		if [ "$?" -ne "0" ] || [ "$_VAL" = "" ]; then
			init_source
		else
			source=$_VAL
		fi

		# FILE FETCHING
		# always needed files
		echo "Getting file sizes (for x*.tgz)"
		fetch_listing "${TEMPS}/dirlisting.txt"

		echo "Fetch source $source."
		echo "Fetching SHA256 sums and index."
		fetch_files --nocomp SHA256 index.txt

		echo "Fetching new boot files and kernels."
		fetch_files bsd.rd bsd
		echo "Fetching architecture dependent files. Some may fail."
		echo "Boot files will not be installed, update manually."
		fetch_files --nocheck bsd.mp boot ofwboot

		# fetch only selected files
		echo "Fetching base packages."
		PKGS="base etc comp game man xbase xetc xfont xserv xshare"

		for pkg in $PKGS; do
			get_config $pkg
			if [ "$?" -ne "0" ]; then
				yesno "Do you wish to add \"$pkg\" to the list of packages to be installed?"
				if [ "$?" -eq 0 ]; then
					ans=yes
				else
					ans=no
				fi
				set_config $pkg $ans
				if [ "$?" -ne 0 ]; then
					echo "Failed to set configuration."
					exit 1
				fi
			elif [ "$_VAL" = "yes" ] || [ "$_VAL" = "no" ]; then
				ans=$_VAL
			fi

			# Fetch it
			if [ "$ans" != "no" ]; then
				query_index $pkg
				fetch_files $_VAL
			fi
		done

		# now install kernels
		yesno "About to install kernels, are you sure?" n
		if [ "$?" -eq 1 ]; then
			echo "User requested abort!"
			exit 1
		fi

		cp -f /bsd /bsd.orig
		cp -f "${TEMPS}/"bsd* /

		echo "Kernel(s) installed"

		get_config "disabled_drivers"
		if [ "$?" -ne "0" ]; then
			echo -n "List of drivers to be disabled? (Usually empty) "
			read ans
			set_config "disabled_drivers" "$ans"
			if [ "$?" -ne "0" ]; then
				echo "Failed to set configuration."
				exit 1
			fi
		else
			ans=$_VAL
		fi

		if [ -n "$ans" ]; then
			for disabled_driver in $ans; do
				disabled_drivers="${disabled_drivers}disable ${disabled_driver}\n"
			done
			disabled_drivers="${disabled_drivers}\nquit\n"
			printf "$disabled_drivers" | config -ef /bsd
			printf "$disabled_drivers" | config -ef /bsd.mp
		fi

		echo "New config state written, reboot and re-run this script after reboot"
		set_config state install_base
	;;
	"install_base" )
		# install the base packages
		yesno "About to install base packages, are you sure?" n
		if [ "$?" -eq 1 ]; then
			echo "User requested abort!"
			exit 1
		fi

		local sysmerge_cmd=
		for pkg in "${TEMPS}/"*.tgz; do
			echo "$pkg" | egrep -q "/etc..\.tgz$"
			if [ "$?" -eq 0 ]; then
				sysmerge_cmd="$sysmerge_cmd -s $pkg"
				echo "Skipping ${pkg}: merge with sysmerge!"
				continue
			fi
			echo "$pkg" | egrep -q "/xetc..\.tgz$"
			if [ "$?" -eq 0 ]; then
				sysmerge_cmd="$sysmerge_cmd -x $pkg"
				echo "Skipping ${pkg}: merge with sysmerge!"
				continue
			fi
			echo "Installing $pkg"
			(cd / && tar zxfp "$pkg") || break
		done

		echo "Base installed."

		set_config state install_kernel

		if [ -n "$sysmerge_cmd" ]; then
			yesno "Run sysmerge (recommended)?"
			if [ "$?" -eq 0 ]; then
				sysmerge $sysmerge_cmd
			fi
		fi

	;;
esac
