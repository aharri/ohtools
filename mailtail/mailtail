#!/usr/local/bin/php
<?php

function imap_execute($cmd, &$pipes)
{
	$lines = array();
	if (fwrite($pipes[0], "command-finished $cmd\n") === FALSE)
		return false;
	if (!fflush($pipes[0]))
		return false;
	while (true) {
		if (($line = fgets($pipes[1])) === FALSE)
			return false;	
		$lines[] = $line;
		if (preg_match('#command-finished.*\n$#', $line))
			break;
	}
	return $lines;
}

$descriptorspec = array(
	0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
	1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
	2 => array("pipe", "r")   // stderr is a pipe that the child will read from
);

$cwd = '/tmp';
$env = array('USER' => 'iku', 'HOME' => '/home/iku');
// $env = array();

$process = proc_open('/usr/local/sbin/dovecot --exec-mail imap', $descriptorspec, $pipes, $cwd, $env);

if (is_resource($process)) {
	// $pipes now looks like this:
	// 0 => writeable handle connected to child stdin
	// 1 => readable handle connected to child stdout
	// Any error output will be appended to /tmp/error-output.txt

	$mailboxes = array();
	$lines = imap_execute('list "*" "*"', $pipes);

	foreach ($lines as $line) {
		if (preg_match('#\* LIST \(.*\) ".*" "(.+)"#', $line, $matches) == 1) {
			print ("Adding mailbox {$matches[1]}\n");
			$mailboxes[] = $matches[1];
		}
	}
	// Fall back to INBOX
	if (empty($mailboxes))
		$mailboxes = array('inbox');

	while (true) {
		foreach ($mailboxes as $mailbox) {
			imap_execute("select $mailbox", $pipes);
			$lines = imap_execute("fetch 1:* flags", $pipes);

			$recent_mails = array();
			foreach ($lines as $line) {
				if (preg_match("#^\* (\d+) FETCH.*\(.*Recent.*\).*#", $line, $matches))
					$recent_mails[] = $matches[1];
			}
			foreach ($recent_mails as $recent_mail) {
				$lines = imap_execute("fetch $recent_mail (body[header.fields (date from to subject)])", $pipes);
				for ($i=1; $i<5; $i++) {
					print ($lines[$i]);
				}
				print("\n");
			}
		}
		sleep(20);
	}

	// It is important that you close any pipes before calling
	// proc_close in order to avoid a deadlock
	fclose($pipes[0]);
	fclose($pipes[1]);
	fclose($pipes[2]);
	$return_value = proc_close($process);

	echo "command returned $return_value\n";
}
?>
